# strategies/strategy_base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import pandas as pd
from enum import Enum, auto
from dataclasses import dataclass

class SignalType(Enum):
    BUY = auto()
    SELL = auto()
    HOLD = auto()

# Enhanced Signal class with FreqTrade-style attributes
@dataclass
class Signal:
    """Represents a trade signal generated by a strategy."""
    signal_type: SignalType
    confidence: float
    price: Optional[float] = None
    quantity: Optional[float] = None
    reason: str = ""
    # FreqTrade-style enhancements
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    entry_tag: Optional[str] = None
    exit_tag: Optional[str] = None

    def __repr__(self):
        return f"Signal(type={self.signal_type.name}, conf={self.confidence:.2f}, reason='{self.reason}')"

# Original StrategyBase for backward compatibility
class StrategyBase(ABC):
    """Base abstract class for all trading strategies."""
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config if config is not None else {}
        # Add symbol from config if available
        self.symbol = self.config.get('symbol', 'BTC/USD')

    @abstractmethod
    def populate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Adds necessary indicators and features to the historical data DataFrame.
        This method should be overridden by concrete strategies.
        """
        pass

    @abstractmethod
    def should_buy(self, market_data: Dict[str, Any], current_position: Dict[str, Any]) -> Signal:
        """
        Determines if a buy signal should be generated.
        - market_data: Latest ticker data.
        - current_position: Dictionary of the current position for the symbol.
        """
        pass

    @abstractmethod
    def should_sell(self, market_data: Dict[str, Any], current_position: Dict[str, Any]) -> Signal:
        """
        Determines if a sell signal should be generated.
        - market_data: Latest ticker data.
        - current_position: Dictionary of the current position for the symbol.
        """
        pass

    def get_required_history(self) -> int:
        """Returns the minimum number of historical data points required for the strategy."""
        return 0

    def validate_config(self) -> bool:
        """Validates the strategy's configuration. Returns True if valid, False otherwise."""
        return True

# FreqTrade-style Interface (new addition)
class IStrategy(ABC):
    """FreqTrade-compatible strategy interface"""
    
    # Strategy metadata (FreqTrade-style)
    INTERFACE_VERSION = 3
    can_short: bool = False
    stoploss: float = -0.10
    timeframe: str = '5m'
    startup_candle_count: int = 30
    
    # ROI table (FreqTrade-style)
    minimal_roi = {
        "60": 0.01,
        "30": 0.02,
        "0": 0.04
    }
    
    # Order types
    order_types = {
        'entry': 'market',
        'exit': 'market',
        'stoploss': 'market',
        'stoploss_on_exchange': False,
    }
    
    # Strategy settings
    process_only_new_candles = True
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    
    @abstractmethod
    def populate_indicators(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Add technical indicators to dataframe
        Similar to FreqTrade's populate_indicators
        
        :param dataframe: Dataframe with data from the exchange
        :param metadata: Additional information, like the currently traded pair
        :return: a Dataframe with all mandatory indicators for the strategies
        """
        pass
    
    @abstractmethod
    def populate_entry_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Add buy signal columns to dataframe
        
        :param dataframe: DataFrame populated with indicators
        :param metadata: Additional information, like the currently traded pair
        :return: DataFrame with entry columns populated
        """
        pass
    
    @abstractmethod 
    def populate_exit_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Add sell signal columns to dataframe
        
        :param dataframe: DataFrame populated with indicators
        :param metadata: Additional information, like the currently traded pair
        :return: DataFrame with exit columns populated
        """
        pass
    
    def custom_stoploss(self, pair: str, trade: dict, current_time: str, 
                       current_rate: float, current_profit: float, **kwargs) -> float:
        """
        Custom stoploss logic (FreqTrade-style)
        
        :param pair: Pair that's currently analyzed
        :param trade: trade object
        :param current_time: datetime object, containing the current datetime
        :param current_rate: Rate, calculated based on pricing settings in exit_pricing
        :param current_profit: Current profit (as ratio), calculated based on current_rate
        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy
        :return: New stoploss value, relative to the current_rate
        """
        return self.stoploss
    
    def custom_exit(self, pair: str, trade: dict, current_time: str, 
                   current_rate: float, current_profit: float, **kwargs) -> Optional[str]:
        """
        Custom exit logic (FreqTrade-style)
        
        :param pair: Pair that's currently analyzed
        :param trade: trade object
        :param current_time: datetime object, containing the current datetime
        :param current_rate: Rate, calculated based on pricing settings in exit_pricing
        :param current_profit: Current profit (as ratio), calculated based on current_rate
        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy
        :return: exit reason string or None
        """
        return None
    
    def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float,
                           time_in_force: str, current_time: str, **kwargs) -> bool:
        """
        Called right before placing a entry order.
        Timing for this function is critical, so avoid doing heavy computations or 
        network requests in this method.
        
        :param pair: Pair that's about to be traded
        :param order_type: Order type (as configured in order_types)
        :param amount: Amount in target (base) currency that's going to be traded
        :param rate: Rate that's going to be used when using limit orders
        :param time_in_force: Time in force
        :param current_time: datetime object, containing the current datetime
        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy
        :return: True if trade should proceed, False otherwise
        """
        return True
    
    def confirm_trade_exit(self, pair: str, trade: dict, order_type: str, amount: float,
                          rate: float, time_in_force: str, exit_reason: str,
                          current_time: str, **kwargs) -> bool:
        """
        Called right before placing a exit order.
        Timing for this function is critical, so avoid doing heavy computations or 
        network requests in this method.
        
        :param pair: Pair that's about to be traded
        :param trade: trade object
        :param order_type: Order type (as configured in order_types)
        :param amount: Amount in target (base) currency that's going to be traded
        :param rate: Rate that's going to be used when using limit orders
        :param time_in_force: Time in force
        :param exit_reason: Exit reason
        :param current_time: datetime object, containing the current datetime
        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy
        :return: True if trade should proceed, False otherwise
        """
        return True

# Enhanced StrategyBase that combines both interfaces
class EnhancedStrategyBase(StrategyBase, IStrategy):
    """
    Enhanced strategy base that combines original interface with FreqTrade compatibility
    Provides both the original methods and FreqTrade-style methods
    """
    
    def __init__(self, config: Dict[str, Any] = None, ml_engine=None, data_fetcher=None):
        super().__init__(config)
        self.ml_engine = ml_engine
        self.data_fetcher = data_fetcher
        self._engine_reference = None
        
        # Override FreqTrade defaults with config values
        if config:
            self.symbol = config.get('symbol', self.symbol)
            self.timeframe = config.get('timeframe', self.timeframe)
            self.stoploss = config.get('stoploss', self.stoploss)
            self.startup_candle_count = config.get('startup_candle_count', self.startup_candle_count)
            
            # Override ROI if provided
            if 'minimal_roi' in config:
                self.minimal_roi = config['minimal_roi']
    
    def analyze_ticker(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        FreqTrade-style ticker analysis that combines indicators, entry/exit trends
        This bridges the gap between FreqTrade and original interfaces
        """
        # Populate indicators
        dataframe = self.populate_indicators(dataframe, metadata)
        
        # Populate entry signals
        dataframe = self.populate_entry_trend(dataframe, metadata)
        
        # Populate exit signals  
        dataframe = self.populate_exit_trend(dataframe, metadata)
        
        return dataframe
    
    # Bridge methods to maintain compatibility with existing strategies
    async def should_buy_enhanced(self, market_data: Dict[str, Any], current_position: Dict[str, Any]) -> Signal:
        """Enhanced buy signal that can use FreqTrade-style analysis"""
        # Try to use FreqTrade-style analysis if available
        if hasattr(self, '_last_analyzed_dataframe'):
            df = self._last_analyzed_dataframe
            if not df.empty and 'enter_long' in df.columns:
                latest_signal = df.iloc[-1].get('enter_long', False)
                if latest_signal:
                    confidence = df.iloc[-1].get('enter_confidence', 0.8)
                    entry_tag = df.iloc[-1].get('enter_tag', 'freqtrade_signal')
                    return Signal(
                        signal_type=SignalType.BUY,
                        confidence=confidence,
                        price=market_data.get('price'),
                        reason=f"FreqTrade entry signal: {entry_tag}",
                        entry_tag=entry_tag
                    )
        
        # Fall back to original method
        return await self.should_buy(market_data, current_position)
    
    async def should_sell_enhanced(self, market_data: Dict[str, Any], current_position: Dict[str, Any]) -> Signal:
        """Enhanced sell signal that can use FreqTrade-style analysis"""
        # Try to use FreqTrade-style analysis if available
        if hasattr(self, '_last_analyzed_dataframe'):
            df = self._last_analyzed_dataframe
            if not df.empty and 'exit_long' in df.columns:
                latest_signal = df.iloc[-1].get('exit_long', False)
                if latest_signal:
                    confidence = df.iloc[-1].get('exit_confidence', 0.8)
                    exit_tag = df.iloc[-1].get('exit_tag', 'freqtrade_signal')
                    return Signal(
                        signal_type=SignalType.SELL,
                        confidence=confidence,
                        price=market_data.get('price'),
                        reason=f"FreqTrade exit signal: {exit_tag}",
                        exit_tag=exit_tag
                    )
        
        # Fall back to original method
        return await self.should_sell(market_data, current_position)
    
    # Default implementations of FreqTrade interface (can be overridden)
    def populate_indicators(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """Default implementation - calls original populate_indicators method"""
        return super().populate_indicators(dataframe)
    
    def populate_entry_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """Default implementation - no entry signals"""
        dataframe['enter_long'] = False
        if self.can_short:
            dataframe['enter_short'] = False
        return dataframe
    
    def populate_exit_trend(self, dataframe: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """Default implementation - no exit signals"""
        dataframe['exit_long'] = False
        if self.can_short:
            dataframe['exit_short'] = False
        return dataframe

# Utility functions for technical analysis (FreqTrade-style)
def merge_informative_pair(dataframe: pd.DataFrame, informative: pd.DataFrame,
                          timeframe: str, timeframe_inf: str, ffill: bool = True) -> pd.DataFrame:
    """
    Merge informative pair data into main dataframe
    Similar to FreqTrade's merge_informative_pair
    """
    if len(informative) == 0:
        return dataframe
    
    # Rename columns to include timeframe suffix
    informative_columns = {col: f"{col}_{timeframe_inf}" for col in informative.columns if col != 'date'}
    informative_renamed = informative.rename(columns=informative_columns)
    
    # Merge on timestamp
    merged = pd.merge(dataframe, informative_renamed, left_index=True, right_index=True, how='left')
    
    if ffill:
        # Forward fill missing values
        for col in informative_columns.values():
            if col in merged.columns:
                merged[col] = merged[col].fillna(method='ffill')
    
    return merged

# Technical indicator helper functions
def crossed_above(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """Check if series1 crossed above series2"""
    return (series1 > series2) & (series1.shift(1) <= series2.shift(1))

def crossed_below(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """Check if series1 crossed below series2"""
    return (series1 < series2) & (series1.shift(1) >= series2.shift(1))

def crossed(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """Check if series1 crossed series2 in either direction"""
    return crossed_above(series1, series2) | crossed_below(series1, series2)